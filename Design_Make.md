# Gitlite 项目设计文档

>可在[此链接](https://notes.sjtu.edu.cn/s/fXK4i9Hpu)查看该文档

## 概述

`Gitlite` 模拟了 `Git` 的核心功能。项目采用 `PIMPL`（`Pointer to IMPLementation`）设计模式，实现了包括提交管理、分支操作、合并冲突解决和远程仓库管理等完整功能。

## 文件结构
```
GITLITE/
├── build/                   #编译文件和存储文件
│    ├── .gitlite/               #git的管理区，后文介绍
│    ├── CMakeFiles/
│    ···
│    └── MakeFile
│
├── include/                 #头文件
│    ├── GitliteException.h
│    ├── Repoitory.h
│    ├── SomeObj.h
│    └── Utils.h
│
├── src/                     #主文件
│    ├── GitliteException.cpp    #异常处理
│    ├── Repoitory.cpp           #仓库初始化与管理
│    ├── SomeObj.cpp             #Gitlite核心功能
│    └── Utils.cpp               #哈希、文件操作、序列化等工具函数
│
├── CMakeLists.txt           #编译文件
├── main.cpp                 #主程序
└── Design_Make.md           #设计文档
```

## 类的定义

###  核心类结构

#### 1 `SomeObj` 类（主接口类）
- **设计模式**：`PIMPL`（`Pointer to IMPLementation`）
- **主要成员**：
  - `std::unique_ptr<Impl> pImpl`：指向内部实现类的智能指针
- **作用**：提供所有 `Gitlite` 命令的公共接口

#### 2 `SomeObj::Impl` 类（核心实现类）

**状态管理变量**：
| 变量名 | 类型 | 作用 |
|--------|------|------|
| `gitliteDir` | `std::string` | 仓库根目录路径（固定为 "`.gitlite`"） |
| `headPath` | `std::string` | `HEAD` 文件路径，指向当前分支 |
| `objectsDir` | `std::string` | 对象存储目录 |
| `stagingPath` | `std::string` | 暂存区状态文件路径 |
| `remoteDir` | `std::string` | 远程仓库配置目录 |
| `currentBranch` | `std::string` | 当前活动分支名称 |

**状态数据变量**：
| 变量名 | 类型 | 作用 |
|--------|------|------|
| `stagedFiles` | `std::map<std::string, std::string>` | 暂存文件映射（文件名 → `blob`哈希） |
| `removedFiles` | `std::set<std::string>` | 标记为删除的文件集合 |
| `remotes` | `std::map<std::string, std::string>` | 远程仓库配置（远程名 → 路径） |

#### 3 `Repository` 类（仓库初始化类）
- **作用**：负责 `.gitlite` 仓库的初始化和基础结构管理
- **静态变量**：
  - `static std::string gitliteDir`：仓库根目录名称（固定为 "`.gitlite`"）
- **主要方法**：
  - `init()`：初始化新的 Gitlite 仓库
  - `exists()`：检查仓库是否已存在
  - `getGitliteDir()`：获取仓库目录路径
  - `createDirectories()`：创建仓库目录结构
  - `createInitialCommit()`：创建初始提交
  - `createInitialBranch()`：创建初始 master 分支

## 工作原理

### 1. 核心算法

#### 1.1 合并冲突检测算法
合并操作是 `Gitlite` 中最复杂的算法，其工作原理如下：

**合并流程**：
1. **寻找分割点**：使用 `BFS` 查找两个提交的最低公共祖先
2. **文件状态分析**：对比三个提交（当前、目标、分割点）中每个文件的状态
3. **冲突检测**：
   - 在两个分支中都修改了同一文件，且修改内容不同
   - 在当前分支中删除文件，在目标分支中修改同一文件
   - 在当前分支中修改文件，在目标分支中删除同一文件
4. **自动合并**：对于无冲突的修改，自动应用变更
5. **冲突标记**：对于冲突文件，生成标准冲突标记格式

**冲突文件格式**：
```
<<<<<<< HEAD
当前分支的内容
=======
目标分支的内容
```

#### 1.2 分支切换安全检查
在 `checkout` 和 `reset` 操作中，系统会检查是否会覆盖未跟踪文件：

**检查逻辑**：
1. 获取目标提交的文件列表
2. 对于每个在目标提交中存在但在当前提交中不存在的文件：
   - 检查该文件是否在工作目录中存在
   - 如果存在且未被跟踪（不在暂存区），则阻止操作
3. 防止意外数据丢失

### 2. 边界情况处理

#### 2.1 空仓库处理
- 初始提交的父提交设为 "`0`"
- 时间戳固定为 `Thu Jan 01 00:00:00 1970 +0000`
- `HEAD` 初始指向 `master` 分支

#### 2.2 无效操作处理
- **重复初始化**：检测到已有 `.gitlite` 目录时拒绝操作
- **无效文件操作**：检查文件存在性后再执行操作
- **无效提交引用**：支持短哈希（至少4位）的自动扩展

#### 2.3 合并特殊情况
- **快速前进**：如果当前分支是目标分支的祖先，直接移动分支指针
- **无需合并**：如果目标分支是当前分支的祖先，不做任何操作
- **合并冲突**：生成冲突文件并允许用户手动解决

### 3. 提交对象生命周期

**提交创建流程**：
1. 收集暂存区文件状态
2. 从父提交继承未修改的文件
3. 计算所有文件的 `SHA-1` 哈希
4. 构建提交对象（消息、父提交、时间戳、文件列表）
5. 保存提交对象到 `objects` 目录
6. 更新分支引用

## 持久化实现

### 1. `.gitlite` 目录结构
```
.gitlite/
├── HEAD               # 当前分支引用
├── objects/           # 对象存储
│ └── <40位SHA-1哈希>  # blob和commit对象
├── refs/
│ ├── heads/           # 本地分支
│ │ └── <分支名>       # 分支指向的提交
│ └── remotes/         # 远程分支
└── STAGING            # 暂存区状态
```

### 2. 序列化格式

#### 2.1 提交对象序列化（四行格式）
```
<提交消息>
<父提交哈希>（合并提交有两行）
<时间戳>
<blob数量>
<blob哈希1> <文件名1>
<blob哈希2> <文件名2>
...
```

**例**：
```
initial commit
0
Thu Jan 01 00:00:00 1970 +0000
0
```

#### 2.2 暂存区状态序列化（`STAGING` 文件）
```
<暂存文件数量>
<文件名1>
<哈希值1>
<文件名2>
<哈希值2>
...
<待删除文件数量>
<待删除文件名1>
<待删除文件名2>
...
```

#### 2.3 远程配置序列化（`REMOTES` 文件）
```
<远程仓库数量>
<远程名1>
<路径1>
<远程名2>
<路径2>
...
```

### 3. 对象存储机制

#### 3.1 Blob 对象
- **存储内容**：文件的原始内容
- **命名方式**：使用文件内容的 `SHA-1` 哈希（40位十六进制）
- **存储位置**：`.gitlite/objects/<hash>`

#### 3.2 Commit 对象
- **存储内容**：提交的元数据和文件引用
- **命名方式**：使用提交内容的 `SHA-1` 哈希
- **特点**：自包含，可通过哈希验证完整性

### 4. 状态管理策略

#### 4.1 懒加载模式
- 在 `Impl` 构造函数中加载持久化状态
- 只在需要时读取文件内容
- 状态变更后立即持久化

#### 4.2 一致性保证
- 操作前进行完整性检查
- 使用原子写入避免部分写入问题
- 重要状态文件有备份机制

#### 4.3 性能优化
- 使用 `std::map` 和 `std::set` 进行快速查找
- 哈希计算只在必要时进行
- 批量操作减少文件 `I/O`

##
编写：林函锋